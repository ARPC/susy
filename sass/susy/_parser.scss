// Parser
// ======
// - susy-compile [function]
// - susy-parse [function]
// - susy-normalize [function]
// - susy-normalize-span [function]
// - susy-normalize-columns [function]
// - susy-normalize-spread [function]
// - susy-normalize-location [function]



// Compile
// -------
/// Combines parsed shorthand
/// with local and global config,
/// normalizing the results
/// into a standard Susy settings map.
///
/// @group x-parser
///
/// @param {list | map} $shorthand -
///   Shorthand expression to define the width of the span,
///   optionally containing:
///   - a count, length, or column-list span;
///   - `at $n`, `first`, or `last` location on asymmetrical grids;
///   - `narrow`, `wide`, or `wider` for optionally spreading
///     across adjacent gutters;
///   - `of $n <spread>` for available grid columns
///     and spread of the container
///     (span counts like `of 6` are only valid
///     in the context of symmetrical grids);
///   - and `set-gutters $n` to override global gutter settings
/// @param {map} $config [null] -
///   Optional map of Susy grid configuration settings
/// @param {bool} $context-only [false] -
///   Allow the parser to ignore span and span-spread values,
///   only parsing context and container-spread
///
/// @return {map} -
///   Parsed and normalized map of settings,
///   based on global and local configuration,
///   alongwith shorthad adjustments.
///
/// @example scss -
///   $user-input: 3 wide of susy-repeat(6, 120px) set-gutters 10px;
///   $grid-data: susy-compile($user-input, $susy);
///
///   @each $key, $value in $grid-data {
///     /* #{$key}: #{$value}, */
///   }
@function susy-compile(
  $short,
  $config: null,
  $context-only: false
) {
  // Get and normalize config
  $config: if($config, susy-settings($config), susy-settings());
  $normal-config: susy-normalize($config);

  // Parse and normalize shorthand
  @if (type-of($short) != 'map') and (length($short) > 0) {
    $short: susy-parse($short, $context-only);
  }

  $normal-short: susy-normalize($short, $normal-config);

  // Merge and return
  @return map-merge($normal-config, $normal-short);
}



// Parse
// -----
/// Parse shorthand span expression
///
/// @group x-parser
///
/// @param {list} $shorthand -
///   Shorthand expression to define the width of the span,
///   optionally containing:
///   - a count, length, or column-list span;
///   - `at $n`, `first`, or `last` location on asymmetrical grids;
///   - `narrow`, `wide`, or `wider` for optionally spreading
///     across adjacent gutters;
///   - `of $n <spread>` for available grid columns
///     and spread of the container
///     (span counts like `of 6` are only valid
///     in the context of symmetrical grids);
///   - and `set-gutters $n` to override global gutter settings
/// @param {bool} $context-only [false] -
///   Allow the parser to ignore span and span-spread values,
///   only parsing context and container-spread
///
/// @return {map} -
///   Map of span settings
///   (`span`, `location`, `columns`, `gutters`, `spread`, `container-spread`)
///   parsed from shorthand input
@function susy-parse(
  $shorthand,
  $context-only: false
) {
  $parse-error: 'Unknown shorthand property:';
  $options: (
    'first': 'location',
    'last': 'location',
    'alpha': 'location',
    'omega': 'location',
    'narrow': 'spread',
    'wide': 'spread',
    'wider': 'spread',
  );

  $return: ();
  $span: null;
  $columns: null;

  $of: null;
  $next: false;

  // Allow context-only shorthand, without span
  @if ($context-only) and (not index($shorthand, 'of')) {
    @if su-valid-columns($shorthand, 'fail-silent') {
      $shorthand: 'of' $shorthand;
    } @else {
      $shorthand: join('of', $shorthand);
    }
  }

  // loop through the shorthand list
  @for $i from 1 through length($shorthand) {
    $item: nth($shorthand, $i);
    $type: type-of($item);
    $details: '[#{$type}] `#{$item}`';

    // if we know what's supposed to be coming next…
    @if $next {

      // Add to the return map
      $return: map-merge($return, ($next: $item));

      // Reset next to `false`
      $next: false;

    } @else { // If we don't know what's supposed to be coming…

      // Keywords…
      @if ($type == 'string') {
        // Check the map for keywords…
        @if map-has-key($options, $item) {
          $setting: map-get($options, $item);

          // Spread could be on the span or the container…
          @if ($setting == 'spread') and ($of) {
            $return: map-merge($return, ('container-spread': $item));
          } @else {
            $return: map-merge($return, ($setting: $item));
          }

        } @else if ($item == 'all') {
          // `All` is a span shortcut
          $span: 'all';
        } @else if ($item == 'at') {
          // Some keywords setup what's next…
          $next: 'location';
        } @else if ($item == 'set-gutters') {
          $next: 'gutters';
        } @else if ($item == 'of') {
          $of: true;
        } @else {
          // Error if we're out of ideas
          @return _susy-error('#{$parse-error} #{$details}', 'susy-parse');
        }

      } @else if ($type == 'number') or ($type == 'list') { // Numbers & lists…

        @if not ($span or $of) {
          // We don't have a span, and we're not expecting context…
          $span: $item;
        } @else if ($of) and (not $columns) {
          // We are expecting context…
          $columns: $item;
        } @else {
          // Error if we don't understand…
          @return _susy-error('#{$parse-error} #{$details}', 'susy-parse');
        }

      } @else {
        // Error if we don't know this type…
        @return _susy-error('#{$parse-error} #{$details}', 'susy-parse');
      }
    }
  }

  // If we have span, merge it in
  @if $span {
    $return: map-merge($return, ('span': $span));
  }

  // If we have columns, merge them in
  @if $columns {
    $return: map-merge($return, ('columns': $columns));
  }

  // Return the map of settings…
  @return $return;
}



// Susy Normalize
// --------------
/// Normalize the values in a configuration map
///
/// @group x-parser
///
/// @param {map} $config -
///   Map of Susy configuration settings to normalize
/// @param {map | null} $context [null] -
///   Map of Susy configuration settings to use as global reference,
///   or `null` to access global settings
///
/// @return {map} -
///   Map of Susy configuration settings, with all values normalized
@function susy-normalize(
  $config,
  $context: null
) {
  // Spread
  @each $setting in ('spread', 'container-spread') {
    $value: map-get($config, $setting);

    @if $value {
      $value: susy-normalize-spread($value);
      $config: map-merge($config, ($setting: $value));
    }
  }

  // Columns
  $columns: map-get($config, 'columns');

  @if $columns {
    $columns: susy-normalize-columns($columns, $context);
    $config: map-merge($config, ('columns': $columns));
  }

  @if not $columns {
    $map: type-of($context) == 'map';
    $columns: if($map, map-get($context, 'columns'), null);
    $columns: $columns or susy-get('columns');
  }

  // Span
  $span: map-get($config, 'span');

  @if $span {
    $span: susy-normalize-span($span, $columns);
    $config: map-merge($config, ('span': $span));
  }

  // Location
  $location: map-get($config, 'location');

  @if $location {
    $location: susy-normalize-location($span, $location, $columns);
    $config: map-merge($config, ('location': $location));
  }

  @return $config;
}



// Normalize Span
// --------------
/// Normalize `span` shorthand for Su
///
/// @group x-parser
///
/// @param {number | list | 'all'} $span -
///   Span value to normalize
/// @param {list} $columns -
///   Normalized list of columns in the grid
///
/// @return {number | list} -
///   Number or list value for `$span`
@function susy-normalize-span(
  $span,
  $columns: susy-get('columns')
) {
  @if ($span == 'all') {
    @return length($columns);
  }

  @return $span;
}



// Normalize Columns
// -----------------
/// Normalize `column` slice shorthand for Su
///
/// @group x-parser
///
/// @param {list | integer} $columns -
///   List of available columns,
///   or unitless integer representing a slice of
///   available the context
/// @param {map | null} $context [null] -
///   Map of Susy configuration settings to use as global reference,
///   or `null` to access global settings
/// @return {list} -
///   Columns value, normalized into a list
/// @throws When attempting to access slice of asymmetrical context
@function susy-normalize-columns(
  $columns,
  $context: null
) {
  $context: $context or susy-settings();

  @if type-of($columns) == 'list' {
    @return _susy-flatten($columns);
  }

  @if (type-of($columns) == 'number') and (unitless($columns)) {
    $span: $columns;
    $context: map-get($context, 'columns');
    $symmetrical: susy-repeat(length($context), nth($context, 1));

    @if ($context == $symmetrical) {
      @return susy-repeat($span, nth($context, 1));
    } @else {
      $actual: 'of `#{$span}`';
      $columns: 'grid-columns `#{$context}`';
      @return _susy-error(
        'context-slice #{$actual} can not be determined based on #{$columns}.',
        'susy-normalize-columns');
    }
  }

  @return $columns;
}



// Normalize Spread
// ----------------
/// Normalize `spread` shorthand for Su
///
/// @group x-parser
///
/// @param {0 | 1 | -1 | 'narrow' | 'wide' | 'wider'} $spread -
///   Spread across adjacent gutters, relative to a column-count —
///   either `narrow` (-1), `wide` (0), or `wider` (1)
///
/// @return {number} -
///   Numeric value for `$spread`
@function susy-normalize-spread(
  $spread
) {
  $normal-spread: (
    'narrow': -1,
    'wide': 0,
    'wider': 1,
  );

  @return map-get($normal-spread, $spread) or $spread;
}



// Normalize Location
// ------------------
/// Normalize `location` shorthand for Su
///
/// @group x-parser
///
/// @param {number} $span -
///   Number of grid-columns to be spanned
/// @param {integer | 'first' | 'last'} $location -
///   Starting (1-indexed) column position of a span,
///   or a named location keyword
/// @param {list} $columns -
///   Normalized list of columns in the grid
///
/// @return {integer} -
///   Numeric value for `$location`
@function susy-normalize-location(
  $span,
  $location,
  $columns
) {
  $count: length($columns);
  $normal-locations: (
    'first': 1,
    'alpha': 1,
    'last': $count - $span + 1,
    'omega': $count - $span + 1,
  );

  @return map-get($normal-locations, $location) or $location;
}
